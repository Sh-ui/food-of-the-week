---
interface MealNavItem {
  id: string;
  title: string;
  cooked: boolean;
}

interface Props {
  shortTitle: string;
  meals: MealNavItem[];
  hasGroceryList: boolean;
}

const { shortTitle, meals, hasGroceryList } = Astro.props;
---

<header class="sticky-header" id="sticky-header" data-scrolled="false">
  <nav class="header-nav">
    <!-- All nav buttons in one container - order matters -->
    <div class="nav-buttons">
      <!-- Date range button - only visible when scrolled -->
      <a href="#top" class="nav-btn date-btn">{shortTitle}</a>
      
        {hasGroceryList && (
        <a href="#print-section-grocery-list" class="nav-btn" data-section="grocery-list">
            Grocery
          </a>
        )}
        
        {meals.map((meal) => (
          <a 
            href={`#print-section-${meal.id}`} 
          class={`nav-btn ${meal.cooked ? 'cooked' : ''}`}
            data-section={meal.id}
          >
            {meal.cooked ? '✓ ' : ''}{meal.title}
          </a>
        ))}
        
      <a href="#site-footer" class="nav-btn" data-section="footer">Links</a>
      </div>
    
    <!-- Mobile: Date button (separate from desktop, appears on scroll) -->
    <a href="#top" class="mobile-date-btn">{shortTitle}</a>
      
      <!-- Mobile: Section selector with dropdown -->
      <div class="section-selector">
        <button class="section-selector-btn" aria-expanded="false" aria-haspopup="true">
          <svg class="dropdown-caret" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="6 9 12 15 18 9"></polyline>
          </svg>
          <span class="current-section-name">Full Week</span>
        </button>
        
        <div class="section-dropdown" hidden>
          <a href="#top" class="dropdown-link">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <line x1="12" y1="19" x2="12" y2="5"></line>
              <polyline points="5 12 12 5 19 12"></polyline>
            </svg>
            Back to Top
          </a>
          
          {hasGroceryList && (
            <a href="#print-section-grocery-list" class="dropdown-link" data-section="grocery-list">
              Grocery List
            </a>
          )}
          
          {meals.map((meal) => (
            <a 
              href={`#print-section-${meal.id}`} 
              class={`dropdown-link ${meal.cooked ? 'cooked' : ''}`}
              data-section={meal.id}
            >
              {meal.cooked ? '✓ ' : ''}{meal.title}
            </a>
          ))}
          
          <a href="#site-footer" class="dropdown-link" data-section="footer">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="10"></circle>
              <line x1="12" y1="16" x2="12" y2="12"></line>
              <line x1="12" y1="8" x2="12.01" y2="8"></line>
            </svg>
            Links & Info
          </a>
      </div>
    </div>
    
    <!-- Print Button -->
    <button class="header-print-btn print-button" data-print-target="all" type="button">
      <svg class="print-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polyline points="6 9 6 2 18 2 18 9"></polyline>
        <path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path>
        <rect x="6" y="14" width="12" height="8"></rect>
      </svg>
      <span class="print-prefix">Print</span>
      <span class="print-section-name">Full Week</span>
    </button>
  </nav>
</header>

<div class="header-spacer"></div>

<style>
  .sticky-header {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 100;
    background: var(--color-bg);
    border-bottom: 1px solid var(--color-border);
  }

  .sticky-header[data-scrolled="true"] {
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }

  .header-spacer {
    height: 56px;
  }

  .header-nav {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: var(--spacing-sm) var(--spacing-md);
    max-width: 1200px;
    margin: 0 auto;
    min-height: 40px;
    position: relative;
  }

  /* When scrolled, align to left */
  .sticky-header[data-scrolled="true"] .header-nav {
    justify-content: flex-start;
  }

  /* ============================================
     NAV BUTTONS CONTAINER - Two states
     ============================================ */
  .nav-buttons {
    display: flex;
    align-items: center;
    gap: var(--spacing-xs);
    transition: opacity 0.2s ease;
  }

  /* ============================================
     NAV BUTTONS - All buttons share base style
     ============================================ */
  .nav-btn {
    padding: 8px 12px;
    height: 36px;
    border-radius: 4px;
    text-decoration: none;
    color: var(--color-text);
    font-size: 0.9rem;
    font-weight: 500;
    line-height: 1;
    white-space: nowrap;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s ease, color 0.2s ease;
  }

  .nav-btn:hover {
    background: var(--color-bg-alt);
  }

  .nav-btn.active {
    background: var(--color-bg-alt);
    color: var(--color-primary);
    font-weight: 600;
  }

  .nav-btn.cooked {
    color: var(--color-cooked-text);
    opacity: 0.7;
  }

  .nav-btn.cooked.active {
    background: var(--color-cooked-bg);
  }

  /* ============================================
     DATE BUTTON - Same as nav buttons, just bigger font
     ============================================ */
  .date-btn {
    font-family: var(--font-heading);
    font-weight: 700;
    font-size: 1.1rem;
    color: var(--color-primary);
    /* Hidden when not scrolled */
    display: none;
  }

  /* Show date button when scrolled */
  .sticky-header[data-scrolled="true"] .date-btn {
    display: inline-flex;
  }

  /* ============================================
     MOBILE DATE BUTTON - Separate from desktop
     ============================================ */
  .mobile-date-btn {
    display: none;
    position: absolute;
    left: var(--spacing-md);
    padding: 8px 12px;
    height: 36px;
    border-radius: 4px;
    text-decoration: none;
    font-family: var(--font-heading);
    font-weight: 700;
    font-size: 1rem;
    color: var(--color-primary);
    line-height: 1;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s ease, opacity 0.2s ease;
    opacity: 0;
    pointer-events: none;
  }

  .mobile-date-btn:hover {
    background: var(--color-bg-alt);
  }

  /* ============================================
     FADE TRANSITION BETWEEN STATES
     ============================================ */
  .sticky-header[data-scrolled="fading"] .nav-buttons {
    opacity: 0;
  }

  /* ============================================
     SECTION SELECTOR (Mobile dropdown)
     ============================================ */
  .section-selector {
    display: none;
    position: relative;
  }

  .section-selector-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 8px 12px;
    height: 36px;
    background: transparent;
    border: none;
    border-radius: 4px;
    font-family: inherit;
    font-size: 1rem;
    font-weight: 600;
    color: var(--color-primary);
    cursor: pointer;
    transition: background-color 0.2s ease;
    line-height: 1;
  }

  .section-selector-btn:hover {
    background: var(--color-bg-alt);
  }

  .dropdown-caret {
    flex-shrink: 0;
    transition: transform 0.2s ease;
  }

  .section-selector-btn[aria-expanded="true"] .dropdown-caret {
    transform: rotate(180deg);
  }

  .current-section-name {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 200px;
  }

  .section-dropdown {
    position: absolute;
    top: calc(100% + 10px);
    left: 50%;
    transform: translateX(-50%);
    min-width: 280px;
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: 12px;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.18);
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 4px;
    z-index: 10;
  }

  .section-dropdown[hidden] {
    display: none;
  }

  .dropdown-link {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    padding: 14px 18px;
    text-decoration: none;
    color: var(--color-text);
    font-size: 1.1rem;
    border-radius: 8px;
    transition: background-color 0.2s ease;
  }

  .dropdown-link:hover {
    background: var(--color-bg-alt);
  }

  .dropdown-link.active {
    background: var(--color-bg-alt);
    font-weight: 600;
    color: var(--color-primary);
  }

  .dropdown-link.cooked {
    color: var(--color-cooked-text);
  }

  .dropdown-link svg {
    flex-shrink: 0;
    opacity: 0.6;
  }

  /* ============================================
     PRINT BUTTON
     ============================================ */
  .header-print-btn {
    position: absolute;
    right: var(--spacing-md);
    padding: 8px 14px;
    border-radius: 4px;
    font-size: 0.9rem;
    font-weight: 500;
    white-space: nowrap;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    border: none;
    background: var(--color-primary);
    color: white;
    font-family: inherit;
    line-height: 1;
    cursor: pointer;
    height: 36px;
    min-width: 36px;
  }

  .header-print-btn:hover {
    background: #3a3626;
  }

  .header-print-btn[data-is-section="true"] {
    background: var(--color-secondary);
    color: var(--color-text);
  }

  .header-print-btn[data-is-section="true"]:hover {
    background: #d9b130;
  }

  .header-print-btn .print-icon {
    display: none;
    flex-shrink: 0;
  }

  .header-print-btn .print-prefix,
  .header-print-btn .print-section-name {
    display: inline;
  }

  .header-print-btn .print-prefix::after {
    content: ' ';
  }

  /* ============================================
     TABLET - 1000px
     ============================================ */
  @media (max-width: 1000px) {
    .header-print-btn .print-icon {
      display: inline;
    }

    .header-print-btn .print-prefix {
      display: none;
    }

    .nav-btn {
      font-size: 0.85rem;
      padding: 8px 10px;
    }

    .date-btn {
      font-size: 1rem;
    }
  }

  /* ============================================
     MOBILE - 950px
     ============================================ */
  @media (max-width: 950px) {
    /* Mobile header stays centered - no left-align on scroll */
    .sticky-header[data-scrolled="true"] .header-nav {
      justify-content: center;
    }

    .nav-buttons {
      display: none;
    }

    .section-selector {
      display: block;
    }

    /* Mobile date button - show the element, but keep invisible until scrolled */
    .mobile-date-btn {
      display: inline-flex;
    }

    /* Fade in mobile date button when scrolled */
    .sticky-header[data-scrolled="true"] .mobile-date-btn {
      opacity: 1;
      pointer-events: auto;
    }

    .header-print-btn {
      padding: 8px 20px;
      min-width: 52px;
    }

    .header-print-btn .print-prefix,
    .header-print-btn .print-section-name {
      display: none;
    }

    .header-print-btn .print-icon {
      display: inline;
    }
  }

  /* ============================================
     SMALL MOBILE - 500px
     ============================================ */
  @media (max-width: 500px) {
    .header-print-btn {
      padding: 8px 16px;
      min-width: 48px;
    }

    .current-section-name {
      max-width: 140px;
    }

    .section-selector-btn {
      padding: 8px 10px;
    }
  }
</style>

<script>
  // ============================================
  // PRINT FUNCTIONALITY
  // ============================================

  interface PrintConfig {
    page: { margins: { top: string; right: string; bottom: string; left: string } };
    typography: {
      bodyFontFamily: string; headingFontFamily: string; bodyFontSize: string;
      lineHeight: number; h1Size: string; h2Size: string; h3Size: string;
    };
    spacing: { sectionGap: string; paragraphGap: string; listItemGap: string; categoryGap: string };
    colors: { text: string; border: string; mutedText: string; headingColor: string };
    checkbox: { size: string; borderWidth: string; checkedSymbol: string; globalCheckedSymbol: string };
    groceryList: { columns: number; showCategories: boolean; categoryHeadingSize: string };
    meals: { pageBreakBetween: boolean; showPhaseColors: boolean; instructionIndent: string };
  }

  interface GroceryItem { text: string; globallyChecked: boolean; }
  interface GroceryCategory { name: string; items: GroceryItem[]; }
  interface Meal {
    id: string; number: number; title: string; fullTitle: string; cooked: boolean;
    protein?: string; ingredients?: string; description?: string;
    alreadyPrepped?: string[]; sousChef?: string; chefFinishing?: string;
  }
  interface WeekPlan { weekTitle: string; groceryList: GroceryCategory[]; meals: Meal[]; }

  let printConfig: PrintConfig | null = null;

  function getDefaultPrintConfig(): PrintConfig {
    return {
      page: { margins: { top: '0.5in', right: '0.5in', bottom: '0.5in', left: '0.5in' } },
      typography: {
        bodyFontFamily: 'Work Sans, sans-serif', headingFontFamily: 'Aleo, Georgia, serif',
        bodyFontSize: '11pt', lineHeight: 1.5, h1Size: '24pt', h2Size: '18pt', h3Size: '14pt'
      },
      spacing: { sectionGap: '16pt', paragraphGap: '8pt', listItemGap: '4pt', categoryGap: '12pt' },
      colors: { text: '#000000', border: '#cccccc', mutedText: '#666666', headingColor: '#333333' },
      checkbox: { size: '12pt', borderWidth: '1pt', checkedSymbol: '✓', globalCheckedSymbol: '●' },
      groceryList: { columns: 1, showCategories: true, categoryHeadingSize: '14pt' },
      meals: { pageBreakBetween: true, showPhaseColors: false, instructionIndent: '0pt' }
    };
  }

  async function loadPrintConfig(): Promise<PrintConfig> {
    if (printConfig) return printConfig;
    try {
      const baseUrl = document.querySelector('link[rel="icon"]')?.getAttribute('href')?.replace('favicon.svg', '') || '/';
      const response = await fetch(`${baseUrl}print-config.json`);
      printConfig = await response.json();
      return printConfig!;
    } catch { return getDefaultPrintConfig(); }
  }

  function getWeekPlanData(): WeekPlan {
    const weekTitle = document.querySelector('h1')?.textContent || 'Weekly Meal Plan';
    const groceryList: GroceryCategory[] = [];
    const grocerySection = document.querySelector('#print-section-grocery-list');
    if (grocerySection) {
      grocerySection.querySelectorAll('.grocery-category').forEach(cat => {
        const name = cat.querySelector('h3')?.textContent || '';
        const items: GroceryItem[] = [];
        cat.querySelectorAll('.grocery-item').forEach(item => {
          const checkbox = item.querySelector('input[type="checkbox"]') as HTMLInputElement;
          const text = item.querySelector('.item-text')?.textContent || '';
          items.push({ text, globallyChecked: checkbox?.dataset.globallyChecked === 'true' });
        });
        groceryList.push({ name, items });
      });
    }
    const meals: Meal[] = [];
    document.querySelectorAll('.meal[data-section-type="meal"]').forEach((mealSection, index) => {
      const id = mealSection.id.replace('print-section-', '');
      const cooked = mealSection.getAttribute('data-cooked') === 'true';
      const fullTitle = mealSection.querySelector('h2')?.textContent || '';
      const number = index + 1; // Use index, not parsed from title
      const title = fullTitle;
      // Extract from flex-parsing structure
      let protein = '', ingredients = '', description = '';
      // First group (.info-group) contains meal info
      const infoGroup = mealSection.querySelector('.info-group');
      if (infoGroup) {
        infoGroup.querySelectorAll('.subsection-field').forEach(field => {
          const label = field.querySelector('strong')?.textContent?.replace(':', '') || '';
          const text = field.textContent?.replace(label + ':', '').trim() || '';
          if (label.toLowerCase().includes('protein')) protein = text;
          if (label.toLowerCase().includes('ingredients')) ingredients = text;
          if (label.toLowerCase().includes('description')) description = text;
        });
      }
      // Instruction groups contain subsections
      const alreadyPrepped: string[] = [];
      let sousChef = '';
      let chefFinishing = '';
      mealSection.querySelectorAll('.instruction-group').forEach(group => {
        const h3 = group.querySelector('h3');
        const sectionTitle = h3?.textContent?.toLowerCase() || '';
        if (sectionTitle.includes('already') && sectionTitle.includes('prep')) {
          group.querySelectorAll('li').forEach(li => alreadyPrepped.push(li.textContent || ''));
        } else if (sectionTitle.includes('sous') && sectionTitle.includes('chef')) {
          const p: string[] = []; group.querySelectorAll('.subsection-content p').forEach(el => p.push(el.textContent || '')); sousChef = p.join('\n\n');
        } else if (sectionTitle.includes('chef') && sectionTitle.includes('finish')) {
          const p: string[] = []; group.querySelectorAll('.subsection-content p').forEach(el => p.push(el.textContent || '')); chefFinishing = p.join('\n\n');
        }
      });
      meals.push({ id, number, title, fullTitle, cooked, protein, ingredients, description,
        alreadyPrepped: alreadyPrepped.length > 0 ? alreadyPrepped : undefined,
        sousChef: sousChef || undefined, chefFinishing: chefFinishing || undefined });
    });
    return { weekTitle, groceryList, meals };
  }

  function generateGroceryListHTML(list: GroceryCategory[], cfg: PrintConfig): string {
    let html = `<div class="print-grocery-list"><h2 style="font-family:${cfg.typography.headingFontFamily};font-size:${cfg.typography.h2Size};color:${cfg.colors.headingColor};margin-bottom:${cfg.spacing.sectionGap};">Grocery List</h2>`;
    list.forEach(cat => {
      html += `<div style="margin-bottom:${cfg.spacing.categoryGap};">`;
      if (cfg.groceryList.showCategories) html += `<h3 style="font-family:${cfg.typography.headingFontFamily};font-size:${cfg.groceryList.categoryHeadingSize};color:${cfg.colors.headingColor};margin-bottom:${cfg.spacing.listItemGap};">${cat.name}</h3>`;
      html += `<ul style="list-style:none;margin:0;padding:0;">`;
      cat.items.forEach(item => {
        const cbStyle = `display:inline-block;width:${cfg.checkbox.size};height:${cfg.checkbox.size};border:${cfg.checkbox.borderWidth} solid ${cfg.colors.text};margin-right:8pt;vertical-align:middle;text-align:center;line-height:${cfg.checkbox.size};`;
        const sym = item.globallyChecked ? cfg.checkbox.globalCheckedSymbol : '';
        const txtStyle = item.globallyChecked ? `color:${cfg.colors.mutedText};` : `color:${cfg.colors.text};`;
        html += `<li style="margin-bottom:${cfg.spacing.listItemGap};${txtStyle}"><span style="${cbStyle}">${sym}</span>${item.text}</li>`;
      });
      html += `</ul></div>`;
    });
    return html + `</div>`;
  }

  function generateMealHTML(meal: Meal, cfg: PrintConfig): string {
    const tc = meal.cooked ? cfg.colors.mutedText : cfg.colors.text;
    const hc = meal.cooked ? cfg.colors.mutedText : cfg.colors.headingColor;
    let html = `<div class="print-meal" style="color:${tc};${cfg.meals.pageBreakBetween?'page-break-after:always;':''}">
      <h2 style="font-family:${cfg.typography.headingFontFamily};font-size:${cfg.typography.h2Size};color:${hc};margin-bottom:${cfg.spacing.sectionGap};">${meal.fullTitle}</h2>
      <div style="border:1px solid ${cfg.colors.border};padding:10pt;margin-bottom:${cfg.spacing.sectionGap};">`;
    if (meal.protein) html += `<p style="margin-bottom:${cfg.spacing.listItemGap};"><strong>Protein:</strong> ${meal.protein}</p>`;
    if (meal.ingredients) html += `<p style="margin-bottom:${cfg.spacing.listItemGap};"><strong>Ingredients:</strong> ${meal.ingredients}</p>`;
    if (meal.description) html += `<p style="margin-bottom:0;"><strong>Description:</strong> ${meal.description}</p>`;
    html += `</div>`;
    if (meal.alreadyPrepped?.length) {
      html += `<div style="margin-bottom:${cfg.spacing.sectionGap};"><h3 style="font-family:${cfg.typography.headingFontFamily};font-size:${cfg.typography.h3Size};color:${hc};margin-bottom:${cfg.spacing.listItemGap};">Already Prepped</h3><ul style="margin-left:20pt;">`;
      meal.alreadyPrepped.forEach(i => html += `<li style="margin-bottom:${cfg.spacing.listItemGap};">${i}</li>`);
      html += `</ul></div>`;
    }
    if (meal.sousChef) {
      html += `<div style="margin-bottom:${cfg.spacing.sectionGap};"><h3 style="font-family:${cfg.typography.headingFontFamily};font-size:${cfg.typography.h3Size};color:${hc};margin-bottom:${cfg.spacing.listItemGap};">Sous Chef - Prep</h3>`;
      meal.sousChef.split('\n\n').forEach(p => html += `<p style="margin-bottom:${cfg.spacing.paragraphGap};">${p}</p>`);
      html += `</div>`;
    }
    if (meal.chefFinishing) {
      html += `<div style="margin-bottom:${cfg.spacing.sectionGap};"><h3 style="font-family:${cfg.typography.headingFontFamily};font-size:${cfg.typography.h3Size};color:${hc};margin-bottom:${cfg.spacing.listItemGap};">Chef - Finishing & Plating</h3>`;
      meal.chefFinishing.split('\n\n').forEach(p => html += `<p style="margin-bottom:${cfg.spacing.paragraphGap};">${p}</p>`);
      html += `</div>`;
    }
    return html + `</div>`;
  }

  function generatePrintDocument(plan: WeekPlan, cfg: PrintConfig, target: string): string {
    const { margins } = cfg.page;
    let content = '';
    if (target === 'all') {
      content += `<h1 style="font-family:${cfg.typography.headingFontFamily};font-size:${cfg.typography.h1Size};color:${cfg.colors.headingColor};margin-bottom:${cfg.spacing.sectionGap};text-align:center;">${plan.weekTitle}</h1>`;
      content += generateGroceryListHTML(plan.groceryList, cfg);
      content += `<div style="page-break-after:always;"></div>`;
      plan.meals.forEach(m => content += generateMealHTML(m, cfg));
    } else if (target === 'grocery-list') {
      content += `<h1 style="font-family:${cfg.typography.headingFontFamily};font-size:${cfg.typography.h1Size};color:${cfg.colors.headingColor};margin-bottom:${cfg.spacing.sectionGap};">${plan.weekTitle}</h1>`;
      content += generateGroceryListHTML(plan.groceryList, cfg);
    } else if (target.startsWith('meal-')) {
      const num = parseInt(target.replace('meal-', ''), 10);
      const meal = plan.meals.find(m => m.number === num);
      if (meal) content += generateMealHTML(meal, cfg);
    }
    return `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Print - ${plan.weekTitle}</title>
      <link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link href="https://fonts.googleapis.com/css2?family=Aleo:wght@400;600;700&family=Work+Sans:wght@400;500;600&display=swap" rel="stylesheet">
      <style>@page{margin:${margins.top} ${margins.right} ${margins.bottom} ${margins.left};}*{box-sizing:border-box;margin:0;padding:0;}
      body{font-family:${cfg.typography.bodyFontFamily};font-size:${cfg.typography.bodyFontSize};line-height:${cfg.typography.lineHeight};color:${cfg.colors.text};padding:0;}
      strong{font-weight:600;}.print-meal:last-child{page-break-after:auto;}</style>
      </head><body>${content}</body></html>`;
  }

  async function printSection(sectionId: string): Promise<void> {
    const cfg = await loadPrintConfig();
    const plan = getWeekPlanData();
    const html = generatePrintDocument(plan, cfg, sectionId);
    const win = window.open('', '_blank', 'width=800,height=600');
    if (!win) { console.error('Could not open print window'); return; }
    win.document.write(html);
    win.document.close();
    win.onload = () => { setTimeout(() => { win.print(); win.close(); }, 250); };
  }

  // ============================================
  // HEADER STATE MANAGEMENT - Simple two-state toggle
  // ============================================

  const header = document.getElementById('sticky-header') as HTMLElement;
  const navButtons = document.querySelector('.nav-buttons') as HTMLElement;
  const sectionSelectorBtn = document.querySelector('.section-selector-btn') as HTMLButtonElement;
  const sectionDropdown = document.querySelector('.section-dropdown') as HTMLElement;
  const currentSectionName = document.querySelector('.current-section-name') as HTMLElement;
  const headerPrintBtn = document.querySelector('.header-print-btn') as HTMLButtonElement;
  const navBtns = document.querySelectorAll('.nav-btn[data-section], .dropdown-link[data-section]') as NodeListOf<HTMLAnchorElement>;

  let isScrolled = false;
  let currentSection = 'all';
  let isFadingIn = false;

  // Simple scroll detection - toggle between two states
  function updateScrollState(): void {
    const scrolled = window.scrollY > 100;
    
    if (scrolled !== isScrolled) {
      isScrolled = scrolled;

      // Fade out
      if (navButtons) {
        navButtons.style.opacity = '0';
  }

      // After fade, switch state and fade back in
      setTimeout(() => {
        header.dataset.scrolled = scrolled ? 'true' : 'false';
        
        setTimeout(() => {
          if (navButtons) {
            navButtons.style.opacity = '1';
          }
        }, 50);
      }, 150);
    }
    
    // Update active section based on scroll position
    updateActiveSection();
  }

  // Track which section is in view with proper opacity handling
  function updateActiveSection(): void {
    const scrollY = window.scrollY;
    const viewportHeight = window.innerHeight;
    const viewportMidpoint = scrollY + (viewportHeight * 0.5);
    
    // At top of page (not scrolled), always show Full Week
    if (scrollY <= 100) {
      if (currentSection !== 'all') {
        currentSection = 'all';
        updateNavHighlight('all');
        updateMobileSelector('all');
        fadeInPrintButton('all');
      } else if (headerPrintBtn) {
        // Ensure full opacity when at top
        headerPrintBtn.style.opacity = '1';
      }
      return;
    }
    
    // Build section data
    interface SectionData { id: string; top: number; bottom: number; height: number; }
    const sections: SectionData[] = [];
    document.querySelectorAll('.print-section').forEach(el => {
      const rect = el.getBoundingClientRect();
      sections.push({
        id: el.id.replace('print-section-', ''),
        top: rect.top + scrollY,
        bottom: rect.bottom + scrollY,
        height: rect.height
      });
    });
    
    // Find which section the viewport midpoint is in
    let foundSection: string | null = null;
    let foundSectionData: SectionData | null = null;
    
    for (const section of sections) {
      if (viewportMidpoint >= section.top && viewportMidpoint < section.bottom) {
        foundSection = section.id;
        foundSectionData = section;
        break;
      }
    }

    // Check for footer section (doesn't have .print-section class)
    const footer = document.getElementById('site-footer');
    if (footer) {
      const footerRect = footer.getBoundingClientRect();
      const footerTop = footerRect.top + scrollY;
      const footerBottom = footerRect.bottom + scrollY;
      
      if (viewportMidpoint >= footerTop && viewportMidpoint < footerBottom) {
        foundSection = 'footer';
        foundSectionData = {
          id: 'footer',
          top: footerTop,
          bottom: footerBottom,
          height: footerRect.height
        };
      }
  }

    // Also check if we're at the very bottom of the page
    const maxScroll = document.documentElement.scrollHeight - viewportHeight;
    if (scrollY >= maxScroll - 10 && footer) {
      foundSection = 'footer';
      const footerRect = footer.getBoundingClientRect();
      foundSectionData = {
        id: 'footer',
        top: footerRect.top + scrollY,
        bottom: footerRect.bottom + scrollY,
        height: footerRect.height
      };
    }
    
    // If no section found (in a gap between sections), don't change anything
    // The button stays at its current opacity (faded out from previous section)
    if (foundSection === null) {
      return;
    }

    // If section changed, do fade-in animation
    if (foundSection !== currentSection) {
      currentSection = foundSection;
      updateNavHighlight(foundSection);
      updateMobileSelector(foundSection);
      fadeInPrintButton(foundSection);
      return;
    }
    
    // Still in same section - handle scroll-mapped fade-out in last 15%
    if (foundSectionData && !isFadingIn && headerPrintBtn) {
      const positionInSection = viewportMidpoint - foundSectionData.top;
      const sectionProgress = positionInSection / foundSectionData.height;
      
      // Last 15% of section = fade out zone
      if (sectionProgress > 0.85) {
        // Map 0.85-1.0 to 1.0-0.0
        const fadeProgress = (sectionProgress - 0.85) / 0.15;
        const opacity = Math.max(0, 1 - fadeProgress);
        headerPrintBtn.style.transition = 'none';
        headerPrintBtn.style.opacity = opacity.toString();
      } else {
        // Outside fade zone, ensure full opacity (no transition to avoid lag)
        headerPrintBtn.style.transition = 'none';
        headerPrintBtn.style.opacity = '1';
      }
    }
  }

  // Fade in the print button with new section content
  function fadeInPrintButton(sectionId: string): void {
    if (!headerPrintBtn) return;
    
    isFadingIn = true;
    
    // Force opacity to 0, update content
    headerPrintBtn.style.transition = 'none';
    headerPrintBtn.style.opacity = '0';
    updatePrintButton(sectionId);
    
    // Force reflow, then fade in
    headerPrintBtn.offsetHeight;
    headerPrintBtn.style.transition = 'opacity 0.2s ease-out';
    headerPrintBtn.style.opacity = '1';
    
    // Reset flag after animation completes
    setTimeout(() => { isFadingIn = false; }, 200);
  }

  function updateNavHighlight(activeSection: string): void {
    navBtns.forEach(link => {
      const linkSection = link.getAttribute('data-section');
      if (linkSection === activeSection) {
        link.classList.add('active');
      } else {
        link.classList.remove('active');
      }
    });
  }

  function updatePrintButton(sectionId: string): void {
    if (!headerPrintBtn) return;
    
    // Footer section has nothing to print - default to Full Week
    const printTarget = sectionId === 'footer' ? 'all' : sectionId;
    const displayName = getDisplayName(printTarget);
    const isSection = printTarget !== 'all';
    
    headerPrintBtn.dataset.printTarget = printTarget;
      headerPrintBtn.dataset.isSection = isSection ? 'true' : 'false';
    
      const sectionNameEl = headerPrintBtn.querySelector('.print-section-name');
      if (sectionNameEl) {
        sectionNameEl.textContent = displayName;
      }
    }

  function updateMobileSelector(sectionId: string): void {
    if (currentSectionName) {
      currentSectionName.textContent = getDisplayName(sectionId);
    }
  }

  function getDisplayName(sectionId: string): string {
    if (sectionId === 'all') return 'Full Week';
    if (sectionId === 'grocery-list') return 'Grocery List';
    if (sectionId === 'footer') return 'Links & Info';
    if (sectionId.startsWith('meal-')) {
      const mealLink = document.querySelector(`.nav-btn[data-section="${sectionId}"]`);
      if (mealLink) {
        const raw = mealLink.textContent?.trim() || 'Meal';
        return raw.replace(/^[✓\u2713]\s*/, '');
      }
    }
    return sectionId;
  }

  // Close section dropdown
  function closeSectionDropdown(): void {
    if (sectionSelectorBtn && sectionDropdown) {
      sectionSelectorBtn.setAttribute('aria-expanded', 'false');
      sectionDropdown.hidden = true;
    }
  }

  // Section dropdown toggle
  function setupSectionDropdown(): void {
    if (!sectionSelectorBtn || !sectionDropdown) return;

    sectionSelectorBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      const isExpanded = sectionSelectorBtn.getAttribute('aria-expanded') === 'true';
      sectionSelectorBtn.setAttribute('aria-expanded', (!isExpanded).toString());
      sectionDropdown.hidden = isExpanded;
    });

    sectionDropdown.querySelectorAll('a').forEach(link => {
      link.addEventListener('click', closeSectionDropdown);
    });

    document.addEventListener('click', (e) => {
      if (!sectionSelectorBtn.contains(e.target as Node) && !sectionDropdown.contains(e.target as Node)) {
        closeSectionDropdown();
      }
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') closeSectionDropdown();
    });
  }

  // Smooth scroll for nav links
  function setupSmoothScroll(): void {
    document.querySelectorAll('.nav-btn, .dropdown-link, .mobile-date-btn').forEach(link => {
      link.addEventListener('click', (e) => {
        const href = (link as HTMLAnchorElement).getAttribute('href');
        if (href?.startsWith('#')) {
          e.preventDefault();
          
          if (href === '#top') {
            window.scrollTo({ top: 0, behavior: 'smooth' });
            return;
          }
          
          const target = document.querySelector(href);
          if (target) {
            const headerHeight = header.offsetHeight;
            const targetPosition = target.getBoundingClientRect().top + window.scrollY - headerHeight - 20;
            window.scrollTo({ top: targetPosition, behavior: 'smooth' });
          }
        }
      });
    });
  }

  // Print button handler
  function setupPrintButton(): void {
    if (headerPrintBtn) {
      headerPrintBtn.addEventListener('click', () => {
        closeSectionDropdown();
        const target = headerPrintBtn.dataset.printTarget || 'all';
        printSection(target);
      });
    }
  }

  // Initialize
  function init(): void {
    header.dataset.scrolled = 'false';
    updateScrollState();
    setupSectionDropdown();
    setupSmoothScroll();
    setupPrintButton();

    window.addEventListener('scroll', updateScrollState, { passive: true });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
</script>
