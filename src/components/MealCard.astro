---
import type { ContentSection } from '../utils/weekParser';
import { groupSubsections } from '../utils/weekParser';
import { sectionColors, getInstructionColor } from '../config/colors';

interface Props {
  section: ContentSection;
}

const { section } = Astro.props;

// Group subsections for rendering
const groups = groupSubsections(section.subsections);

// Helper function to render markdown links to HTML
function renderMarkdown(text: string): string {
  // Convert markdown links [text](url) to HTML links
  return text.trim().replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
}
---

<div 
  id={`print-section-${section.id}`} 
  class={`print-section meal bg-bg border border-border rounded-lg p-lg mb-xl w-full break-inside-avoid ${section.cooked ? 'meal-cooked' : ''}`}
  data-section-type="meal" 
  data-cooked={section.cooked ? 'true' : 'false'}
>
  <div class="meal-header flex justify-between items-start mb-lg gap-md mobile:flex-col mobile:items-start mobile:gap-md">
    <span 
      class={`cooked-indicator inline-flex items-center justify-center w-7 h-7 border-2 border-[var(--color-text-light)] rounded-full flex-shrink-0 mt-1 text-[0.9rem] select-none mobile:w-8 mobile:h-8 mobile:text-base ${section.cooked ? 'is-cooked' : ''}`}
      aria-label={section.cooked ? 'Meal has been cooked' : 'Meal not yet cooked'}
    >
      {section.cooked ? 'âœ“' : ''}
    </span>
    <h2 class="m-0 flex-1 mobile:text-[2rem]">{section.title}</h2>
  </div>
  
  {/* Render subsection groups */}
  {groups.map((group, groupIndex) => {
    // First group uses firstSubsection colors (meal info)
    // Subsequent groups use cycling instruction colors
    const isFirstGroup = groupIndex === 0;
    const colors = isFirstGroup 
      ? sectionColors.firstSubsection 
      : getInstructionColor(groupIndex - 1);
    
    return (
      <div 
        class={`subsection-group mb-lg p-md rounded-md border-l-4 last:mb-0 ${isFirstGroup ? 'info-group flex flex-col gap-md' : 'instruction-group mt-lg'}`}
        style={`background: ${colors.bg}; border-left-color: ${colors.border};`}
      >
        {group.map((sub) => (
          <div class="subsection">
            {/* For grouped items, show as labeled fields */}
            {isFirstGroup ? (
              <div class="subsection-field leading-relaxed text-[1.1rem] mobile:text-[1.25rem] mobile:leading-extra-loose">
                <strong class="text-primary inline-block min-w-[120px]">{sub.title}:</strong> {sub.content}
              </div>
            ) : (
              <>
                <h3 class="mt-0 mb-md text-[1.25rem] font-semibold mobile:text-[1.3rem] mobile:mb-md" style={`color: ${colors.heading};`}>{sub.title}</h3>
                {sub.items && sub.items.length > 0 && (
                  <ul class="list-disc ml-lg">
                    {sub.items.map((item: string) => (
                      <li class="mb-sm leading-relaxed text-[1.1rem] mobile:text-[1.25rem] mobile:leading-extra-loose" set:html={renderMarkdown(item)} />
                    ))}
                  </ul>
                )}
                {sub.content && (
                  <div class="subsection-content">
                    {sub.content.split('\n\n').map((paragraph: string) => (
                      <p class="mb-md leading-relaxed text-[1.1rem] last:mb-0 mobile:text-[1.25rem] mobile:leading-extra-loose" set:html={renderMarkdown(paragraph)} />
                    ))}
                  </div>
                )}
              </>
            )}
          </div>
        ))}
      </div>
    );
  })}
  
  {/* Empty state */}
  {groups.length === 0 && (
    <div class="empty-state">
      <p>No content available for this section.</p>
    </div>
  )}
</div>

<style>
  /* Cooked indicator - always visible circle, filled when cooked */
  .cooked-indicator {
    color: transparent;
    cursor: default;
  }
  
  .cooked-indicator.is-cooked {
    background: var(--color-cooked-text, #8a887f);
    border-color: var(--color-cooked-text, #8a887f);
    color: white;
  }

  /* Cooked meal state overrides - semantic state styling */
  .meal-cooked {
    background: var(--color-cooked-bg, #f0ede6) !important;
    border-color: var(--color-cooked-border, #d8d4c9) !important;
  }

  .meal-cooked h2 {
    color: var(--color-cooked-text, #8a887f);
  }

  .meal-cooked .subsection-group {
    background: var(--color-cooked-bg, #f0ede6) !important;
    border-left-color: var(--color-cooked-border, #d8d4c9) !important;
  }

  .meal-cooked strong {
    color: var(--color-cooked-text, #8a887f) !important;
  }

  .meal-cooked h3 {
    color: var(--color-cooked-text, #8a887f) !important;
  }

  .meal-cooked li,
  .meal-cooked p {
    color: var(--color-cooked-text, #8a887f);
  }

  .meal-cooked :global(a) {
    color: var(--color-cooked-text);
    text-decoration-color: var(--color-cooked-text);
  }

  /* Markdown link styling */
  .subsection-content :global(a),
  .instruction-group :global(a) {
    color: var(--color-primary);
    text-decoration: underline;
    text-decoration-color: var(--color-accent);
    text-underline-offset: 2px;
    transition: color 0.2s ease;
  }

  .subsection-content :global(a):hover,
  .instruction-group :global(a):hover {
    color: var(--color-accent);
  }

  /* Mobile responsive adjustments for strong tags */
  @media screen(mobile) {
    .subsection-field strong {
      display: block;
      margin-bottom: var(--spacing-xs);
    }
  }
</style>
